"""
Comprehensive test suite for KeycloakClient

Tests are organized into classes by functionality:
- TestKeycloakConfig: Configuration validation
- TestTokenValidation: JWT validation, caching, requirements
- TestOrganizationManagement: CRUD operations for organizations
- TestClientManagement: OAuth2 client management
- TestUserManagement: User CRUD and role assignment
- TestAdminOperations: Admin token handling, permissions
- TestErrorHandling: Exception handling and edge cases
- TestPerformance: Caching, connection pooling
- TestIntegration: End-to-end flows

Run with: pytest tests/test_keycloak_client.py -v
"""

import time
import pytest
import jwt
from datetime import datetime, timedelta
from typing import Dict, Any
from unittest.mock import AsyncMock, MagicMock, patch, Mock
import httpx

from src.keycloak_client.keycloak_client import (
    KeycloakClient,
    KeycloakConfig,
    TokenInfo,
    KeycloakError,
    TokenValidationError,
    create_tenant_infrastructure,
    extract_token_from_header,
)


# =============================================================================
# TEST FIXTURES
# =============================================================================

keycloak_server_url = "http://localhost:8080"


@pytest.fixture
def base_config():
    """Basic KeycloakConfig for testing"""
    return KeycloakConfig(
        server_url="http://localhost:8080",
        realm="test-realm",
        client_id="test-client",
        client_secret="test-secret",
    )


@pytest.fixture
def admin_config():
    """KeycloakConfig with admin credentials"""
    return KeycloakConfig(
        server_url="http://localhost:8080",
        realm="test-realm",
        client_id="test-client",
        client_secret="test-secret",
        admin_client_id="admin-client",
        admin_client_secret="admin-secret",
    )


@pytest.fixture
def mock_http_client():
    """Mock httpx.AsyncClient"""
    client = AsyncMock(spec=httpx.AsyncClient)
    return client


@pytest.fixture
async def keycloak_client(base_config, mock_http_client):
    """KeycloakClient instance with mocked HTTP client"""
    kc = KeycloakClient(base_config)
    kc._http_client = mock_http_client
    yield kc
    # Cleanup
    if kc._http_client and not isinstance(kc._http_client, AsyncMock):
        await kc._http_client.aclose()


@pytest.fixture
async def admin_keycloak_client(admin_config, mock_http_client):
    """KeycloakClient with admin credentials and mocked HTTP client"""
    kc = KeycloakClient(admin_config)
    kc._http_client = mock_http_client
    yield kc
    if kc._http_client and not isinstance(kc._http_client, AsyncMock):
        await kc._http_client.aclose()


@pytest.fixture
def sample_jwt_payload():
    """Sample JWT payload"""
    return {
        "sub": "user-123",
        "email": "test@example.com",
        "preferred_username": "testuser",
        "exp": int(time.time()) + 3600,
        "iat": int(time.time()),
        "iss": "http://localhost:8080/realms/test-realm",
        "aud": "test-client",
        "realm_access": {"roles": ["user", "admin"]},
        "resource_access": {
            "test-client": {"roles": ["client-role"]}
        },
        "scope": "openid profile email",
        "organization_id": "org-123",
        "tenant_id": "tenant-123",
    }


@pytest.fixture
def sample_organization():
    """Sample organization response"""
    return {
        "id": "org-uuid-123",
        "name": "Test Organization",
        "enabled": True,
        "attributes": {
            "tenant_id": ["test-tenant"]
        }
    }


@pytest.fixture
def sample_client():
    """Sample client response"""
    return {
        "id": "client-uuid-123",
        "clientId": "test-backend",
        "enabled": True,
        "secret": "client-secret-123"
    }


@pytest.fixture
def sample_user():
    """Sample user response"""
    return {
        "id": "user-uuid-123",
        "username": "testuser",
        "email": "test@example.com",
        "firstName": "Test",
        "lastName": "User",
        "enabled": True,
        "attributes": {
            "organization_id": ["org-123"]
        }
    }


# =============================================================================
# TEST: Configuration
# =============================================================================

class TestKeycloakConfig:
    """Test KeycloakConfig validation and initialization"""

    def test_config_basic_initialization(self):
        """Test basic config initialization"""
        config = KeycloakConfig(
            server_url="http://localhost:8080",
            realm="test-realm",
            client_id="test-client",
            client_secret="test-secret",
        )
        assert config.server_url == "http://localhost:8080"
        assert config.realm == "test-realm"
        assert config.client_id == "test-client"
        assert config.client_secret == "test-secret"
        assert config.verify_ssl is True
        assert config.token_leeway == 10

    def test_config_with_admin_credentials(self):
        """Test config with admin credentials"""
        config = KeycloakConfig(
            server_url="http://localhost:8080",
            realm="test-realm",
            client_id="test-client",
            client_secret="test-secret",
            admin_client_id="admin-client",
            admin_client_secret="admin-secret",
        )
        assert config.admin_client_id == "admin-client"
        assert config.admin_client_secret == "admin-secret"

    def test_config_ssl_verification_disabled(self):
        """Test config with SSL verification disabled"""
        config = KeycloakConfig(
            server_url="http://localhost:8080",
            realm="test-realm",
            client_id="test-client",
            client_secret="test-secret",
            verify_ssl=False,
        )
        assert config.verify_ssl is False


# =============================================================================
# TEST: Client Initialization
# =============================================================================

class TestKeycloakClientInitialization:
    """Test KeycloakClient initialization and properties"""

    def test_client_initialization(self, base_config):
        """Test client initialization"""
        kc = KeycloakClient(base_config)
        assert kc.config == base_config
        assert kc.base_url == "http://localhost:8080/realms/test-realm"
        assert kc.admin_url == "http://localhost:8080/admin/realms/test-realm"
        assert kc._jwks_client is None
        assert kc._admin_token is None

    async def test_client_context_manager(self, base_config):
        """Test client as async context manager"""
        async with KeycloakClient(base_config) as kc:
            assert kc._http_client is not None
            assert isinstance(kc._http_client, httpx.AsyncClient)

    def test_jwks_client_lazy_initialization(self, keycloak_client):
        """Test JWKS client is lazily initialized"""
        assert keycloak_client._jwks_client is None
        jwks_client = keycloak_client.jwks_client
        assert jwks_client is not None
        assert keycloak_client._jwks_client is jwks_client

    def test_http_client_lazy_initialization(self, base_config):
        """Test HTTP client is lazily initialized"""
        kc = KeycloakClient(base_config)
        assert kc._http_client is None
        http_client = kc.http
        assert http_client is not None


# =============================================================================
# TEST: Token Validation
# =============================================================================

class TestTokenValidation:
    """Test token validation functionality"""

    @pytest.mark.asyncio
    async def test_validate_token_success(self, keycloak_client, sample_jwt_payload):
        """Test successful token validation"""
        # Mock JWKS client
        mock_signing_key = MagicMock()
        mock_signing_key.key = "test-key"

        mock_jwks = MagicMock()
        mock_jwks.get_signing_key_from_jwt.return_value = mock_signing_key
        keycloak_client._jwks_client = mock_jwks

        # Mock jwt.decode
        with patch('jwt.decode', return_value=sample_jwt_payload):
            token_info = await keycloak_client.validate_token("fake.jwt.token")

            assert token_info.sub == "user-123"
            assert token_info.email == "test@example.com"
            assert token_info.username == "testuser"
            assert "user" in token_info.roles
            assert "admin" in token_info.roles
            assert token_info.organization_id == "org-123"
            assert token_info.tenant_id == "tenant-123"

    @pytest.mark.asyncio
    async def test_validate_token_expired(self, keycloak_client):
        """Test validation fails for expired token"""
        mock_signing_key = MagicMock()
        mock_signing_key.key = "test-key"

        mock_jwks = MagicMock()
        mock_jwks.get_signing_key_from_jwt.return_value = mock_signing_key
        keycloak_client._jwks_client = mock_jwks

        with patch('jwt.decode', side_effect=jwt.ExpiredSignatureError()):
            with pytest.raises(TokenValidationError, match="Token has expired"):
                await keycloak_client.validate_token("fake.jwt.token")

    @pytest.mark.asyncio
    async def test_validate_token_invalid_audience(self, keycloak_client):
        """Test validation fails for invalid audience"""
        mock_signing_key = MagicMock()
        mock_signing_key.key = "test-key"

        mock_jwks = MagicMock()
        mock_jwks.get_signing_key_from_jwt.return_value = mock_signing_key
        keycloak_client._jwks_client = mock_jwks

        with patch('jwt.decode', side_effect=jwt.InvalidAudienceError()):
            with pytest.raises(TokenValidationError, match="Invalid token audience"):
                await keycloak_client.validate_token("fake.jwt.token")

    @pytest.mark.asyncio
    async def test_validate_token_required_roles(self, keycloak_client, sample_jwt_payload):
        """Test validation with required roles"""
        mock_signing_key = MagicMock()
        mock_signing_key.key = "test-key"

        mock_jwks = MagicMock()
        mock_jwks.get_signing_key_from_jwt.return_value = mock_signing_key
        keycloak_client._jwks_client = mock_jwks

        with patch('jwt.decode', return_value=sample_jwt_payload):
            # Should succeed - user has required role
            token_info = await keycloak_client.validate_token(
                "fake.jwt.token",
                required_roles=["user"]
            )
            assert token_info is not None

            # Should fail - user missing required role
            with pytest.raises(TokenValidationError, match="Missing required roles"):
                await keycloak_client.validate_token(
                    "fake.jwt.token",
                    required_roles=["superadmin"]
                )

    @pytest.mark.asyncio
    async def test_validate_token_required_scopes(self, keycloak_client, sample_jwt_payload):
        """Test validation with required scopes"""
        mock_signing_key = MagicMock()
        mock_signing_key.key = "test-key"

        mock_jwks = MagicMock()
        mock_jwks.get_signing_key_from_jwt.return_value = mock_signing_key
        keycloak_client._jwks_client = mock_jwks

        with patch('jwt.decode', return_value=sample_jwt_payload):
            # Should succeed
            token_info = await keycloak_client.validate_token(
                "fake.jwt.token",
                required_scopes=["openid"]
            )
            assert token_info is not None

            # Should fail
            with pytest.raises(TokenValidationError, match="Missing required scopes"):
                await keycloak_client.validate_token(
                    "fake.jwt.token",
                    required_scopes=["admin:write"]
                )

    @pytest.mark.asyncio
    async def test_validate_token_caching(self, keycloak_client, sample_jwt_payload):
        """Test token validation caching"""
        mock_signing_key = MagicMock()
        mock_signing_key.key = "test-key"

        mock_jwks = MagicMock()
        mock_jwks.get_signing_key_from_jwt.return_value = mock_signing_key
        keycloak_client._jwks_client = mock_jwks

        with patch('jwt.decode', return_value=sample_jwt_payload) as mock_decode:
            # First validation - should call jwt.decode
            token_info1 = await keycloak_client.validate_token(
                "fake.jwt.token",
                cache_tokens=True
            )
            assert mock_decode.call_count == 1

            # Second validation - should use cache
            token_info2 = await keycloak_client.validate_token(
                "fake.jwt.token",
                cache_tokens=True
            )
            assert mock_decode.call_count == 1  # Not called again
            assert token_info1.sub == token_info2.sub

    @pytest.mark.asyncio
    async def test_validate_token_no_cache(self, keycloak_client, sample_jwt_payload):
        """Test token validation without caching"""
        mock_signing_key = MagicMock()
        mock_signing_key.key = "test-key"

        mock_jwks = MagicMock()
        mock_jwks.get_signing_key_from_jwt.return_value = mock_signing_key
        keycloak_client._jwks_client = mock_jwks

        with patch('jwt.decode', return_value=sample_jwt_payload) as mock_decode:
            # First validation
            await keycloak_client.validate_token(
                "fake.jwt.token",
                cache_tokens=False
            )
            assert mock_decode.call_count == 1

            # Second validation - should call jwt.decode again
            await keycloak_client.validate_token(
                "fake.jwt.token",
                cache_tokens=False
            )
            assert mock_decode.call_count == 2


# =============================================================================
# TEST: Token Introspection
# =============================================================================

class TestTokenIntrospection:
    """Test token introspection endpoint"""

    @pytest.mark.asyncio
    async def test_introspect_token_active(
        self,
        keycloak_client: KeycloakClient,
        mock_http_client,
    ):
        """Test introspection of active token"""
        mock_response = AsyncMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "active": True,
            "sub": "user-123",
            "scope": "openid profile"
        }
        mock_http_client.post.return_value = mock_response

        result = await keycloak_client.introspect_token("fake.token")

        assert result["active"] is True
        assert result["sub"] == "user-123"
        mock_http_client.post.assert_called_once()

    @pytest.mark.asyncio
    async def test_introspect_token_inactive(self, keycloak_client, mock_http_client):
        """Test introspection of inactive token"""
        mock_response = AsyncMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {"active": False}
        mock_http_client.post.return_value = mock_response

        with pytest.raises(TokenValidationError, match="Token is not active"):
            await keycloak_client.introspect_token("fake.token")


# =============================================================================
# TEST: Organization Management
# =============================================================================

class TestOrganizationManagement:
    """Test organization CRUD operations"""

    @pytest.mark.asyncio
    async def test_create_organization_success(
        self,
        admin_keycloak_client,
        mock_http_client,
        sample_organization
    ):
        """Test successful organization creation"""
        # Mock admin token
        admin_keycloak_client._admin_token = "admin-token"
        admin_keycloak_client._admin_token_expires = time.time() + 3600

        # Mock POST response
        mock_post_response = AsyncMock()
        mock_post_response.status_code = 201
        mock_post_response.headers = {
            "Location": "/admin/realms/test-realm/organizations/org-uuid-123"
        }

        # Mock GET response
        mock_get_response = AsyncMock()
        mock_get_response.status_code = 200
        mock_get_response.json.return_value = sample_organization

        mock_http_client.request.side_effect = [mock_post_response, mock_get_response]

        org = await admin_keycloak_client.create_organization(
            name="Test Organization",
            attributes={"tenant_id": ["test-tenant"]}
        )

        assert org["id"] == "org-uuid-123"
        assert org["name"] == "Test Organization"
        assert org["attributes"]["tenant_id"] == ["test-tenant"]

    @pytest.mark.asyncio
    async def test_create_organization_with_string_attributes(
        self,
        admin_keycloak_client,
        mock_http_client,
        sample_organization
    ):
        """Test organization creation with string attributes (auto-converted to list)"""
        admin_keycloak_client._admin_token = "admin-token"
        admin_keycloak_client._admin_token_expires = time.time() + 3600

        mock_post_response = AsyncMock()
        mock_post_response.status_code = 201
        mock_post_response.headers = {
            "Location": "/admin/realms/test-realm/organizations/org-uuid-123"
        }

        mock_get_response = AsyncMock()
        mock_get_response.status_code = 200
        mock_get_response.json.return_value = sample_organization

        mock_http_client.request.side_effect = [mock_post_response, mock_get_response]

        # Pass string instead of list
        org = await admin_keycloak_client.create_organization(
            name="Test Organization",
            attributes={"tenant_id": "test-tenant"}  # String, not list
        )

        assert org["attributes"]["tenant_id"] == ["test-tenant"]

    @pytest.mark.asyncio
    async def test_get_organization(
        self,
        admin_keycloak_client,
        mock_http_client,
        sample_organization
    ):
        """Test getting organization by ID"""
        admin_keycloak_client._admin_token = "admin-token"
        admin_keycloak_client._admin_token_expires = time.time() + 3600

        mock_response = AsyncMock()
        mock_response.status_code = 200
        mock_response.json.return_value = sample_organization
        mock_http_client.request.return_value = mock_response

        org = await admin_keycloak_client.get_organization("org-uuid-123")

        assert org["id"] == "org-uuid-123"
        assert org["name"] == "Test Organization"

    @pytest.mark.asyncio
    async def test_list_organizations(
        self,
        admin_keycloak_client,
        mock_http_client,
        sample_organization
    ):
        """Test listing all organizations"""
        admin_keycloak_client._admin_token = "admin-token"
        admin_keycloak_client._admin_token_expires = time.time() + 3600

        mock_response = AsyncMock()
        mock_response.status_code = 200
        mock_response.json.return_value = [sample_organization]
        mock_http_client.request.return_value = mock_response

        orgs = await admin_keycloak_client.list_organizations()

        assert len(orgs) == 1
        assert orgs[0]["id"] == "org-uuid-123"

    @pytest.mark.asyncio
    async def test_delete_organization(
        self,
        admin_keycloak_client,
        mock_http_client
    ):
        """Test deleting organization"""
        admin_keycloak_client._admin_token = "admin-token"
        admin_keycloak_client._admin_token_expires = time.time() + 3600

        mock_response = AsyncMock()
        mock_response.status_code = 204
        mock_http_client.request.return_value = mock_response

        await admin_keycloak_client.delete_organization("org-uuid-123")

        mock_http_client.request.assert_called_once()


# =============================================================================
# TEST: Client Management
# =============================================================================

class TestClientManagement:
    """Test OAuth2 client management"""

    @pytest.mark.asyncio
    async def test_create_client_success(
        self,
        admin_keycloak_client,
        mock_http_client,
        sample_client
    ):
        """Test successful client creation"""
        admin_keycloak_client._admin_token = "admin-token"
        admin_keycloak_client._admin_token_expires = time.time() + 3600

        # Mock POST response
        mock_post_response = AsyncMock()
        mock_post_response.status_code = 201

        # Mock list clients response
        mock_list_response = AsyncMock()
        mock_list_response.status_code = 200
        mock_list_response.json.return_value = [sample_client]

        # Mock get secret response
        mock_secret_response = AsyncMock()
        mock_secret_response.status_code = 200
        mock_secret_response.json.return_value = {"value": "client-secret-123"}

        mock_http_client.request.side_effect = [
            mock_post_response,
            mock_list_response,
            mock_secret_response
        ]

        client = await admin_keycloak_client.create_client(
            client_id="test-backend",
            organization_id="org-123",
            redirect_uris=["https://example.com/callback"]
        )

        assert client["clientId"] == "test-backend"
        assert client["secret"] == "client-secret-123"

    @pytest.mark.asyncio
    async def test_list_clients(
        self,
        admin_keycloak_client,
        mock_http_client,
        sample_client
    ):
        """Test listing clients"""
        admin_keycloak_client._admin_token = "admin-token"
        admin_keycloak_client._admin_token_expires = time.time() + 3600

        mock_response = AsyncMock()
        mock_response.status_code = 200
        mock_response.json.return_value = [sample_client]
        mock_http_client.request.return_value = mock_response

        clients = await admin_keycloak_client.list_clients(client_id="test-backend")

        assert len(clients) == 1
        assert clients[0]["clientId"] == "test-backend"

    @pytest.mark.asyncio
    async def test_get_client_secret(
        self,
        admin_keycloak_client,
        mock_http_client
    ):
        """Test getting client secret"""
        admin_keycloak_client._admin_token = "admin-token"
        admin_keycloak_client._admin_token_expires = time.time() + 3600

        mock_response = AsyncMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {"value": "super-secret"}
        mock_http_client.request.return_value = mock_response

        secret = await admin_keycloak_client.get_client_secret("client-uuid-123")

        assert secret == "super-secret"

    @pytest.mark.asyncio
    async def test_delete_client(
        self,
        admin_keycloak_client,
        mock_http_client
    ):
        """Test deleting client"""
        admin_keycloak_client._admin_token = "admin-token"
        admin_keycloak_client._admin_token_expires = time.time() + 3600

        mock_response = AsyncMock()
        mock_response.status_code = 204
        mock_http_client.request.return_value = mock_response

        await admin_keycloak_client.delete_client("client-uuid-123")

        mock_http_client.request.assert_called_once()


# =============================================================================
# TEST: User Management
# =============================================================================

class TestUserManagement:
    """Test user CRUD operations"""

    @pytest.mark.asyncio
    async def test_create_user_success(
        self,
        admin_keycloak_client,
        mock_http_client,
        sample_user
    ):
        """Test successful user creation"""
        admin_keycloak_client._admin_token = "admin-token"
        admin_keycloak_client._admin_token_expires = time.time() + 3600

        # Mock POST response
        mock_post_response = AsyncMock()
        mock_post_response.status_code = 201
        mock_post_response.headers = {
            "Location": "/admin/realms/test-realm/users/user-uuid-123"
        }

        # Mock GET response
        mock_get_response = AsyncMock()
        mock_get_response.status_code = 200
        mock_get_response.json.return_value = sample_user

        mock_http_client.request.side_effect = [mock_post_response, mock_get_response]

        user = await admin_keycloak_client.create_user(
            username="testuser",
            email="test@example.com",
            first_name="Test",
            last_name="User",
            organization_id="org-123"
        )

        assert user["id"] == "user-uuid-123"
        assert user["username"] == "testuser"
        assert user["attributes"]["organization_id"] == ["org-123"]

    @pytest.mark.asyncio
    async def test_get_user(
        self,
        admin_keycloak_client,
        mock_http_client,
        sample_user
    ):
        """Test getting user by ID"""
        admin_keycloak_client._admin_token = "admin-token"
        admin_keycloak_client._admin_token_expires = time.time() + 3600

        mock_response = AsyncMock()
        mock_response.status_code = 200
        mock_response.json.return_value = sample_user
        mock_http_client.request.return_value = mock_response

        user = await admin_keycloak_client.get_user("user-uuid-123")

        assert user["id"] == "user-uuid-123"
        assert user["username"] == "testuser"

    @pytest.mark.asyncio
    async def test_list_users(
        self,
        admin_keycloak_client,
        mock_http_client,
        sample_user
    ):
        """Test listing users"""
        admin_keycloak_client._admin_token = "admin-token"
        admin_keycloak_client._admin_token_expires = time.time() + 3600

        mock_response = AsyncMock()
        mock_response.status_code = 200
        mock_response.json.return_value = [sample_user]
        mock_http_client.request.return_value = mock_response

        users = await admin_keycloak_client.list_users(search="testuser")

        assert len(users) == 1
        assert users[0]["username"] == "testuser"

    @pytest.mark.asyncio
    async def test_list_users_by_organization(
        self,
        admin_keycloak_client,
        mock_http_client,
        sample_user
    ):
        """Test listing users filtered by organization"""
        admin_keycloak_client._admin_token = "admin-token"
        admin_keycloak_client._admin_token_expires = time.time() + 3600

        # Return users with different org IDs
        users_data = [
            {**sample_user, "id": "user-1", "attributes": {"organization_id": ["org-123"]}},
            {**sample_user, "id": "user-2", "attributes": {"organization_id": ["org-456"]}},
        ]

        mock_response = AsyncMock()
        mock_response.status_code = 200
        mock_response.json.return_value = users_data
        mock_http_client.request.return_value = mock_response

        users = await admin_keycloak_client.list_users(organization_id="org-123")

        assert len(users) == 1
        assert users[0]["id"] == "user-1"

    @pytest.mark.asyncio
    async def test_delete_user(
        self,
        admin_keycloak_client,
        mock_http_client
    ):
        """Test deleting user"""
        admin_keycloak_client._admin_token = "admin-token"
        admin_keycloak_client._admin_token_expires = time.time() + 3600

        mock_response = AsyncMock()
        mock_response.status_code = 204
        mock_http_client.request.return_value = mock_response

        await admin_keycloak_client.delete_user("user-uuid-123")

        mock_http_client.request.assert_called_once()

    @pytest.mark.asyncio
    async def test_set_user_password(
        self,
        admin_keycloak_client,
        mock_http_client
    ):
        """Test setting user password"""
        admin_keycloak_client._admin_token = "admin-token"
        admin_keycloak_client._admin_token_expires = time.time() + 3600

        mock_response = AsyncMock()
        mock_response.status_code = 204
        mock_http_client.request.return_value = mock_response

        await admin_keycloak_client.set_user_password(
            "user-uuid-123",
            "NewPassword123!",
            temporary=True
        )

        mock_http_client.request.assert_called_once()


# =============================================================================
# TEST: Role Management
# =============================================================================

class TestRoleManagement:
    """Test role assignment operations"""

    @pytest.mark.asyncio
    async def test_assign_realm_role_to_user(
        self,
        admin_keycloak_client,
        mock_http_client
    ):
        """Test assigning realm role to user"""
        admin_keycloak_client._admin_token = "admin-token"
        admin_keycloak_client._admin_token_expires = time.time() + 3600

        # Mock get role response
        mock_get_role_response = AsyncMock()
        mock_get_role_response.status_code = 200
        mock_get_role_response.json.return_value = {
            "id": "role-uuid-123",
            "name": "admin"
        }

        # Mock assign role response
        mock_assign_response = AsyncMock()
        mock_assign_response.status_code = 204

        mock_http_client.request.side_effect = [
            mock_get_role_response,
            mock_assign_response
        ]

        await admin_keycloak_client.assign_realm_role_to_user(
            "user-uuid-123",
            "admin"
        )

        assert mock_http_client.request.call_count == 2


# =============================================================================
# TEST: Admin Token Management
# =============================================================================

class TestAdminTokenManagement:
    """Test admin token acquisition and caching"""

    @pytest.mark.asyncio
    async def test_get_admin_token_success(
        self,
        admin_keycloak_client,
        mock_http_client
    ):
        """Test successful admin token acquisition"""
        mock_response = AsyncMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "access_token": "admin-access-token",
            "expires_in": 3600
        }
        mock_http_client.post.return_value = mock_response

        token = await admin_keycloak_client._get_admin_token()

        assert token == "admin-access-token"
        assert admin_keycloak_client._admin_token == "admin-access-token"
        assert admin_keycloak_client._admin_token_expires > time.time()

    @pytest.mark.asyncio
    async def test_get_admin_token_cached(
        self,
        admin_keycloak_client,
        mock_http_client
    ):
        """Test admin token caching"""
        # Set cached token
        admin_keycloak_client._admin_token = "cached-token"
        admin_keycloak_client._admin_token_expires = time.time() + 3600

        token = await admin_keycloak_client._get_admin_token()

        assert token == "cached-token"
        mock_http_client.post.assert_not_called()

    @pytest.mark.asyncio
    async def test_get_admin_token_no_credentials(
        self,
        keycloak_client
    ):
        """Test admin token fails without credentials"""
        with pytest.raises(KeycloakError, match="Admin credentials not configured"):
            await keycloak_client._get_admin_token()

    @pytest.mark.asyncio
    async def test_admin_request_with_token(
        self,
        admin_keycloak_client,
        mock_http_client
    ):
        """Test admin request includes bearer token"""
        # Mock admin token
        admin_keycloak_client._admin_token = "admin-token"
        admin_keycloak_client._admin_token_expires = time.time() + 3600

        mock_response = AsyncMock()
        mock_response.status_code = 200
        mock_http_client.request.return_value = mock_response

        await admin_keycloak_client._admin_request("GET", "/test")

        # Verify Authorization header was set
        call_kwargs = mock_http_client.request.call_args[1]
        assert call_kwargs["headers"]["Authorization"] == "Bearer admin-token"


# =============================================================================
# TEST: Well-Known Configuration
# =============================================================================

class TestWellKnownConfiguration:
    """Test OpenID Connect discovery"""

    @pytest.mark.asyncio
    async def test_get_wellknown_config(
        self,
        keycloak_client,
        mock_http_client
    ):
        """Test getting well-known configuration"""
        mock_response = AsyncMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "issuer": "http://localhost:8080/realms/test-realm",
            "authorization_endpoint": "http://localhost:8080/realms/test-realm/protocol/openid-connect/auth",
            "token_endpoint": "http://localhost:8080/realms/test-realm/protocol/openid-connect/token",
            "jwks_uri": "http://localhost:8080/realms/test-realm/protocol/openid-connect/certs"
        }
        mock_http_client.get.return_value = mock_response

        config = await keycloak_client.get_wellknown_config()

        assert config["issuer"] == "http://localhost:8080/realms/test-realm"
        assert "authorization_endpoint" in config
        assert "token_endpoint" in config

    @pytest.mark.asyncio
    async def test_get_auth_url(
        self,
        keycloak_client,
        mock_http_client
    ):
        """Test generating authorization URL"""
        mock_response = AsyncMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "authorization_endpoint": "http://localhost:8080/realms/test-realm/protocol/openid-connect/auth"
        }
        mock_http_client.get.return_value = mock_response

        auth_url = await keycloak_client.get_auth_url(
            redirect_uri="https://example.com/callback",
            state="random-state",
            scope="openid profile email"
        )

        assert "client_id=test-client" in auth_url
        assert "redirect_uri=https://example.com/callback" in auth_url
        assert "state=random-state" in auth_url
        assert "scope=openid profile email" in auth_url

    @pytest.mark.asyncio
    async def test_exchange_code_for_token(
        self,
        keycloak_client,
        mock_http_client
    ):
        """Test exchanging authorization code for token"""
        mock_response = AsyncMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "access_token": "access-token-123",
            "refresh_token": "refresh-token-123",
            "expires_in": 3600
        }
        mock_http_client.post.return_value = mock_response

        tokens = await keycloak_client.exchange_code_for_token(
            code="auth-code-123",
            redirect_uri="https://example.com/callback"
        )

        assert tokens["access_token"] == "access-token-123"
        assert tokens["refresh_token"] == "refresh-token-123"
        assert tokens["expires_in"] == 3600


# =============================================================================
# TEST: Error Handling
# =============================================================================

class TestErrorHandling:
    """Test error handling and exception cases"""

    @pytest.mark.asyncio
    async def test_keycloak_error_on_http_error(
        self,
        admin_keycloak_client,
        mock_http_client
    ):
        """Test KeycloakError raised on HTTP errors"""
        admin_keycloak_client._admin_token = "admin-token"
        admin_keycloak_client._admin_token_expires = time.time() + 3600

        mock_response = AsyncMock()
        mock_response.status_code = 500
        mock_response.text = "Internal Server Error"
        mock_http_client.request.return_value = mock_response

        with pytest.raises(KeycloakError, match="Failed to get organization"):
            await admin_keycloak_client.get_organization("org-123")

    @pytest.mark.asyncio
    async def test_token_validation_error_on_invalid_token(
        self,
        keycloak_client
    ):
        """Test TokenValidationError on invalid token"""
        mock_signing_key = MagicMock()
        mock_signing_key.key = "test-key"

        mock_jwks = MagicMock()
        mock_jwks.get_signing_key_from_jwt.return_value = mock_signing_key
        keycloak_client._jwks_client = mock_jwks

        with patch('jwt.decode', side_effect=jwt.InvalidTokenError("Invalid")):
            with pytest.raises(TokenValidationError, match="Invalid token"):
                await keycloak_client.validate_token("bad.token")

    @pytest.mark.asyncio
    async def test_create_organization_error_on_duplicate(
        self,
        admin_keycloak_client,
        mock_http_client
    ):
        """Test error when creating duplicate organization"""
        admin_keycloak_client._admin_token = "admin-token"
        admin_keycloak_client._admin_token_expires = time.time() + 3600

        mock_response = AsyncMock()
        mock_response.status_code = 409
        mock_response.text = "Organization already exists"
        mock_http_client.request.return_value = mock_response

        with pytest.raises(KeycloakError, match="Failed to create organization"):
            await admin_keycloak_client.create_organization(
                name="Duplicate Org",
                attributes={"tenant_id": ["duplicate"]}
            )


# =============================================================================
# TEST: Integration - Tenant Infrastructure
# =============================================================================

class TestTenantInfrastructure:
    """Test complete tenant setup"""

    @pytest.mark.asyncio
    async def test_create_tenant_infrastructure_success(
        self,
        admin_keycloak_client,
        mock_http_client,
        sample_organization,
        sample_client
    ):
        """Test complete tenant infrastructure creation"""
        admin_keycloak_client._admin_token = "admin-token"
        admin_keycloak_client._admin_token_expires = time.time() + 3600

        # Mock organization creation
        mock_org_post = AsyncMock()
        mock_org_post.status_code = 201
        mock_org_post.headers = {
            "Location": "/admin/realms/test-realm/organizations/org-uuid-123"
        }

        mock_org_get = AsyncMock()
        mock_org_get.status_code = 200
        mock_org_get.json.return_value = sample_organization

        # Mock client creation
        mock_client_post = AsyncMock()
        mock_client_post.status_code = 201

        mock_client_list = AsyncMock()
        mock_client_list.status_code = 200
        mock_client_list.json.return_value = [sample_client]

        mock_client_secret = AsyncMock()
        mock_client_secret.status_code = 200
        mock_client_secret.json.return_value = {"value": "client-secret-123"}

        mock_http_client.request.side_effect = [
            mock_org_post,
            mock_org_get,
            mock_client_post,
            mock_client_list,
            mock_client_secret
        ]

        result = await create_tenant_infrastructure(
            admin_client=admin_keycloak_client,
            tenant_name="Test Tenant",
            tenant_id="test-tenant",
            backend_redirect_uris=["https://test-tenant.example.com/callback"]
        )

        assert result["organization"]["id"] == "org-uuid-123"
        assert result["client_id"] == "test-backend"
        assert result["client_secret"] == "client-secret-123"


# =============================================================================
# TEST: Utility Functions
# =============================================================================

class TestUtilityFunctions:
    """Test utility functions"""

    def test_extract_token_from_header_success(self):
        """Test extracting token from Authorization header"""
        token = extract_token_from_header("Bearer abc.def.ghi")
        assert token == "abc.def.ghi"

    def test_extract_token_from_header_invalid(self):
        """Test error on invalid Authorization header"""
        with pytest.raises(ValueError, match="Invalid Authorization header"):
            extract_token_from_header("Basic abc123")

        with pytest.raises(ValueError, match="Invalid Authorization header"):
            extract_token_from_header("abc.def.ghi")


# =============================================================================
# TEST: Performance and Caching
# =============================================================================

class TestPerformanceAndCaching:
    """Test caching and performance optimizations"""

    @pytest.mark.asyncio
    async def test_token_cache_hit_rate(
        self,
        keycloak_client,
        sample_jwt_payload
    ):
        """Test token validation cache performance"""
        mock_signing_key = MagicMock()
        mock_signing_key.key = "test-key"

        mock_jwks = MagicMock()
        mock_jwks.get_signing_key_from_jwt.return_value = mock_signing_key
        keycloak_client._jwks_client = mock_jwks

        with patch('jwt.decode', return_value=sample_jwt_payload) as mock_decode:
            # Validate same token multiple times
            for _ in range(10):
                await keycloak_client.validate_token(
                    "same.token.always",
                    cache_tokens=True
                )

            # Should only decode once
            assert mock_decode.call_count == 1

    @pytest.mark.asyncio
    async def test_admin_token_reuse(
        self,
        admin_keycloak_client,
        mock_http_client
    ):
        """Test admin token is reused across operations"""
        # Mock token endpoint
        mock_token_response = AsyncMock()
        mock_token_response.status_code = 200
        mock_token_response.json.return_value = {
            "access_token": "admin-token",
            "expires_in": 3600
        }
        mock_http_client.post.return_value = mock_token_response

        # Mock admin operations
        mock_admin_response = AsyncMock()
        mock_admin_response.status_code = 200
        mock_admin_response.json.return_value = []
        mock_http_client.request.return_value = mock_admin_response

        # Perform multiple admin operations
        await admin_keycloak_client.list_organizations()
        await admin_keycloak_client.list_users()
        await admin_keycloak_client.list_clients()

        # Token endpoint should only be called once
        mock_http_client.post.assert_called_once()

    @pytest.mark.asyncio
    async def test_connection_reuse_in_context_manager(
        self,
        base_config
    ):
        """Test HTTP connection pooling in context manager"""
        async with KeycloakClient(base_config) as kc:
            http_client_1 = kc._http_client
            http_client_2 = kc._http_client

            # Should be the same instance
            assert http_client_1 is http_client_2


# =============================================================================
# TEST: Edge Cases
# =============================================================================

class TestEdgeCases:
    """Test edge cases and boundary conditions"""

    @pytest.mark.asyncio
    async def test_validate_token_with_empty_roles(
        self,
        keycloak_client,
        sample_jwt_payload
    ):
        """Test token validation with no roles"""
        payload_no_roles = {**sample_jwt_payload}
        del payload_no_roles["realm_access"]
        del payload_no_roles["resource_access"]

        mock_signing_key = MagicMock()
        mock_signing_key.key = "test-key"

        mock_jwks = MagicMock()
        mock_jwks.get_signing_key_from_jwt.return_value = mock_signing_key
        keycloak_client._jwks_client = mock_jwks

        with patch('jwt.decode', return_value=payload_no_roles):
            token_info = await keycloak_client.validate_token("token")
            assert token_info.roles == []

    @pytest.mark.asyncio
    async def test_validate_token_with_no_organization(
        self,
        keycloak_client,
        sample_jwt_payload
    ):
        """Test token validation without organization claim"""
        payload_no_org = {**sample_jwt_payload}
        del payload_no_org["organization_id"]
        del payload_no_org["tenant_id"]

        mock_signing_key = MagicMock()
        mock_signing_key.key = "test-key"

        mock_jwks = MagicMock()
        mock_jwks.get_signing_key_from_jwt.return_value = mock_signing_key
        keycloak_client._jwks_client = mock_jwks

        with patch('jwt.decode', return_value=payload_no_org):
            token_info = await keycloak_client.validate_token("token")
            assert token_info.organization_id is None
            assert token_info.tenant_id is None

    @pytest.mark.asyncio
    async def test_create_organization_with_empty_attributes(
        self,
        admin_keycloak_client,
        mock_http_client
    ):
        """Test creating organization with no attributes"""
        admin_keycloak_client._admin_token = "admin-token"
        admin_keycloak_client._admin_token_expires = time.time() + 3600

        mock_post_response = AsyncMock()
        mock_post_response.status_code = 201
        mock_post_response.headers = {
            "Location": "/admin/realms/test-realm/organizations/org-uuid-123"
        }

        mock_get_response = AsyncMock()
        mock_get_response.status_code = 200
        mock_get_response.json.return_value = {
            "id": "org-uuid-123",
            "name": "Test Org",
            "enabled": True,
            "attributes": {}
        }

        mock_http_client.request.side_effect = [mock_post_response, mock_get_response]

        org = await admin_keycloak_client.create_organization(
            name="Test Org",
            attributes=None
        )

        assert org["id"] == "org-uuid-123"
        assert org["attributes"] == {}

    @pytest.mark.asyncio
    async def test_list_users_empty_result(
        self,
        admin_keycloak_client,
        mock_http_client
    ):
        """Test listing users with no results"""
        admin_keycloak_client._admin_token = "admin-token"
        admin_keycloak_client._admin_token_expires = time.time() + 3600

        mock_response = AsyncMock()
        mock_response.status_code = 200
        mock_response.json.return_value = []
        mock_http_client.request.return_value = mock_response

        users = await admin_keycloak_client.list_users()

        assert users == []

    def test_token_info_dataclass_creation(self):
        """Test TokenInfo dataclass creation"""
        token_info = TokenInfo(
            sub="user-123",
            email="test@example.com",
            username="testuser",
            roles=["user", "admin"],
            organization_id="org-123",
            tenant_id="tenant-123",
            scopes=["openid", "profile"],
            exp=int(time.time()) + 3600,
            iat=int(time.time()),
            raw_token="raw.jwt.token",
            claims={"custom": "claim"}
        )

        assert token_info.sub == "user-123"
        assert token_info.email == "test@example.com"
        assert "admin" in token_info.roles
        assert token_info.organization_id == "org-123"


# =============================================================================
# TEST: Token Parsing
# =============================================================================

class TestTokenParsing:
    """Test JWT token parsing logic"""

    def test_parse_token_payload_with_all_fields(self, keycloak_client, sample_jwt_payload):
        """Test parsing token with all fields present"""
        token_info = keycloak_client._parse_token_payload(
            sample_jwt_payload,
            "raw.jwt.token"
        )

        assert token_info.sub == "user-123"
        assert token_info.email == "test@example.com"
        assert token_info.username == "testuser"
        assert "user" in token_info.roles
        assert "admin" in token_info.roles
        assert "client-role" in token_info.roles
        assert "openid" in token_info.scopes
        assert token_info.organization_id == "org-123"
        assert token_info.tenant_id == "tenant-123"

    def test_parse_token_payload_minimal(self, keycloak_client):
        """Test parsing token with minimal required fields"""
        minimal_payload = {
            "sub": "user-123",
            "exp": int(time.time()) + 3600,
            "iat": int(time.time()),
        }

        token_info = keycloak_client._parse_token_payload(
            minimal_payload,
            "raw.jwt.token"
        )

        assert token_info.sub == "user-123"
        assert token_info.email is None
        assert token_info.username is None
        assert token_info.roles == []
        assert token_info.scopes == []
        assert token_info.organization_id is None

    def test_parse_token_payload_with_only_realm_roles(self, keycloak_client):
        """Test parsing token with only realm roles"""
        payload = {
            "sub": "user-123",
            "exp": int(time.time()) + 3600,
            "iat": int(time.time()),
            "realm_access": {"roles": ["realm-role-1", "realm-role-2"]}
        }

        token_info = keycloak_client._parse_token_payload(payload, "token")

        assert "realm-role-1" in token_info.roles
        assert "realm-role-2" in token_info.roles

    def test_parse_token_payload_with_only_resource_roles(self, keycloak_client):
        """Test parsing token with only resource access roles"""
        payload = {
            "sub": "user-123",
            "exp": int(time.time()) + 3600,
            "iat": int(time.time()),
            "resource_access": {
                "test-client": {"roles": ["client-role-1", "client-role-2"]}
            }
        }

        token_info = keycloak_client._parse_token_payload(payload, "token")

        assert "client-role-1" in token_info.roles
        assert "client-role-2" in token_info.roles


# =============================================================================
# TEST: Requirements Verification
# =============================================================================

class TestRequirementsVerification:
    """Test role and scope requirement verification"""

    def test_verify_requirements_all_roles_present(self, keycloak_client):
        """Test verification succeeds when all roles present"""
        token_info = TokenInfo(
            sub="user-123",
            email=None,
            username=None,
            roles=["user", "admin", "moderator"],
            organization_id=None,
            tenant_id=None,
            scopes=[],
            exp=int(time.time()) + 3600,
            iat=int(time.time()),
            raw_token="token",
            claims={}
        )

        # Should not raise
        keycloak_client._verify_requirements(
            token_info,
            required_roles=["user", "admin"],
            required_scopes=None
        )

    def test_verify_requirements_missing_roles(self, keycloak_client):
        """Test verification fails when roles missing"""
        token_info = TokenInfo(
            sub="user-123",
            email=None,
            username=None,
            roles=["user"],
            organization_id=None,
            tenant_id=None,
            scopes=[],
            exp=int(time.time()) + 3600,
            iat=int(time.time()),
            raw_token="token",
            claims={}
        )

        with pytest.raises(TokenValidationError, match="Missing required roles: admin"):
            keycloak_client._verify_requirements(
                token_info,
                required_roles=["user", "admin"],
                required_scopes=None
            )

    def test_verify_requirements_all_scopes_present(self, keycloak_client):
        """Test verification succeeds when all scopes present"""
        token_info = TokenInfo(
            sub="user-123",
            email=None,
            username=None,
            roles=[],
            organization_id=None,
            tenant_id=None,
            scopes=["openid", "profile", "email"],
            exp=int(time.time()) + 3600,
            iat=int(time.time()),
            raw_token="token",
            claims={}
        )

        # Should not raise
        keycloak_client._verify_requirements(
            token_info,
            required_roles=None,
            required_scopes=["openid", "profile"]
        )

    def test_verify_requirements_missing_scopes(self, keycloak_client):
        """Test verification fails when scopes missing"""
        token_info = TokenInfo(
            sub="user-123",
            email=None,
            username=None,
            roles=[],
            organization_id=None,
            tenant_id=None,
            scopes=["openid"],
            exp=int(time.time()) + 3600,
            iat=int(time.time()),
            raw_token="token",
            claims={}
        )

        with pytest.raises(TokenValidationError, match="Missing required scopes"):
            keycloak_client._verify_requirements(
                token_info,
                required_roles=None,
                required_scopes=["openid", "profile", "email"]
            )


# =============================================================================
# TEST: Context Manager Behavior
# =============================================================================

class TestContextManagerBehavior:
    """Test async context manager lifecycle"""

    @pytest.mark.asyncio
    async def test_context_manager_creates_http_client(self, base_config):
        """Test context manager creates HTTP client"""
        kc = KeycloakClient(base_config)
        assert kc._http_client is None

        async with kc:
            assert kc._http_client is not None
            assert isinstance(kc._http_client, httpx.AsyncClient)

    @pytest.mark.asyncio
    async def test_context_manager_closes_http_client(self, base_config):
        """Test context manager closes HTTP client on exit"""
        async with KeycloakClient(base_config) as kc:
            http_client = kc._http_client
            assert not http_client.is_closed

        # After context exit, client should be closed
        assert http_client.is_closed


# =============================================================================
# TEST: URL Construction
# =============================================================================

class TestURLConstruction:
    """Test URL construction for various endpoints"""

    def test_base_url_construction(self, base_config):
        """Test base URL is correctly constructed"""
        kc = KeycloakClient(base_config)
        assert kc.base_url == "http://localhost:8080/realms/test-realm"

    def test_admin_url_construction(self, base_config):
        """Test admin URL is correctly constructed"""
        kc = KeycloakClient(base_config)
        assert kc.admin_url == "http://localhost:8080/admin/realms/test-realm"

    def test_jwks_url(self, keycloak_client):
        """Test JWKS URL construction"""
        jwks_client = keycloak_client.jwks_client
        # PyJWKClient stores the URI internally
        assert "protocol/openid-connect/certs" in str(jwks_client.uri)
